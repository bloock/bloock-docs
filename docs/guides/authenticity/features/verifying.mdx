import SdkCodeBlock from '/docs/partials/_sdk-code-block.mdx';

# Verifying

## Signature verification

Once you have some data/document signed, you can verify the digital signature in it by following the integrity verification process that automatically verifies the signatures (if any) or you can do it by your own:

<SdkCodeBlock
js='
const { AuthenticityClient, EcdsaSigner, KeyClient, RecordClient, KeyType } = require("@bloock/sdk");

(async () => {
let keyClient = new KeyClient();
let authenticityClient = new AuthenticityClient();
let recordClient = new RecordClient();

    let key = await keyClient.newLocalKey(KeyType.EcP256k);

    let signedRecord = await recordClient.fromString("Hello world")
        .withSigner(new EcdsaSigner(key, { commonName: "some name" }))
        .build();

    let valid = await authenticityClient.verify(signedRecord);
    if (valid) {
        console.log("Signature was verified successfully");
    }

})();
'
py='
from bloock.client.authenticity import AuthenticityClient
from bloock.client.record import RecordClient
from bloock.client.entity.signer import EcdsaSigner
from bloock.client.key import KeyClient

record_client = RecordClient()
authenticity_client = AuthenticityClient()
key_client = KeyClient()

key = key_client.new_local_key(KeyType.EcP256k)

signed_record = (
record_client.from_string("Hello world")
.with_signer(EcdsaSigner(SignerArgs(key, "some name")))
.build()
)

valid = authenticity_client.verify(signed_record)
if valid == true:
print("Signature was verified successfully")

'
java='
import java.util.List;
import com.bloock.sdk.client.AuthenticityClient;
import com.bloock.sdk.client.RecordClient;
import com.bloock.sdk.entity.EcdsaSigner;
import com.bloock.sdk.entity.EcdsaKeyPair;
import com.bloock.sdk.entity.Record;
import com.bloock.sdk.entity.Signature;
import com.bloock.sdk.entity.SignerArgs;

public class App {
public static void main(String[] args) throws Exception {
RecordClient recordClient = new RecordClient();
AuthenticityClient authenticityClient = new AuthenticityClient();
KeyClient keyClient = new KeyClient();

        LocalKey localKey = keyClient.newLocalKey(KeyType.EcP256k);

        Record signedRecord = recordClient
                .fromString("Hello world")
                .withSigner(new EcdsaSigner(new SignerArgs(localKey, "some name")))
                .build();

        boolean valid = authenticityClient.verify(signedRecord);
        if (valid == true) {
                System.out.println("Signature was verified successfully");
        }
    }

}
'
php='

<?php

require "./vendor/autoload.php";

use Bloock\Bloock;
use Bloock\Client\AuthenticityClient;
use Bloock\Client\KeyClient;
use Bloock\Client\RecordClient;
use Bloock\Entity\Authenticity\EcdsaSigner;
use Bloock\Entity\Authenticity\SignerArgs;
use Bloock\Entity\Key\KeyType;

Bloock::$apiKey = getenv("API_KEY");

$keyClient = new KeyClient();
$authenticityClient = new AuthenticityClient();
$recordClient = new RecordClient();

$keys = $keyClient->newLocalKey(KeyType::EcP256k);

$signedRecord = $recordClient->fromString("Hello world")
    ->withSigner(new EcdsaSigner(new SignerArgs($keys, "some name")))
    ->build();

$valid = $authenticityClient->verify($signedRecord);
if ($valid) {
    print "Signature was verified successfully";
}

'
go='
import (
	"fmt"
	"log"

	"github.com/bloock/bloock-sdk-go/v2/client"
	"github.com/bloock/bloock-sdk-go/v2/entity"
)

func main() {
	recordClient := client.NewRecordClient()
	authenticityClient := client.NewAuthenticityClient()
	keyClient := client.NewKeyClient()

	key, err := keyClient.NewLocalKey(key.EcP256k)
	if err != nil {
		log.Println(err)
	}

	name := "a name"
	signedRecord, err := recordClient.FromString("Hello world").
		WithSigner(entity.NewEcdsaSigner(entity.SignerArgs{
			LocalKey: &key,
			CommonName: &name,
		})).
		Build()
	if err != nil {
		log.Println(err)
	}
	
	valid, err := authenticityClient.Verify(record)
	if err != nil {
		log.Println(err)
	}
	
	if valid == true {
		fmt.Println("Signature was verified successfully")
	}	
'
 />

## Setting a common name

When we sign a record we have the option of setting a common name. This name is protected by the signature, which means that if it's altered, the signature will become invalid.

<SdkCodeBlock
js='
const { AuthenticityClient, EcdsaSigner, KeyClient, RecordClient, KeyType } = require("@bloock/sdk");

(async () => {
    let authenticityClient = new AuthenticityClient();
    let recordClient = new RecordClient();
    let keyClient = new KeyClient();

    let key = await keyClient.newLocalKey(KeyType.EcP256k);

    let signedRecord = await recordClient.fromString("Hello world")
        .withSigner(new EcdsaSigner(key, { commonName: "some name" }))
        .build();

    console.log("Record was signed successfully");

    let signatures = await signedRecord.getSignatures();

    console.log("Record signed by:", await signatures[0].getCommonName());
})();
'
py='
from bloock.client.authenticity import AuthenticityClient
from bloock.client.record import RecordClient
from bloock.client.key import KeyClient
from bloock.client.entity.signer import EcdsaSigner

record_client = RecordClient()
authenticity_client = AuthenticityClient()
key_client = KeyClient()

key = key_client.new_local_key(KeyType.EcP256k)

signed_record = (
    record_client.from_string("Hello world")
    .with_signer(EcdsaSigner(SignerArgs(key, "some name")))
    .build()
)

print("Record was signed sucessfully")

signatures = authenticity_client.get_signatures(signed_record)
signer = authenticity_client.get_signature_common_name(signatures[0])

print("Record signed by:", signer)
'
java='
import java.util.List;

import com.bloock.sdk.client.AuthenticityClient;
import com.bloock.sdk.client.RecordClient;
import com.bloock.sdk.client.KeyClient;
import com.bloock.sdk.entity.EcdsaSigner;
import com.bloock.sdk.entity.Record;
import com.bloock.sdk.entity.Signature;
import com.bloock.sdk.entity.SignerArgs;

public class App {
    public static void main(String[] args) throws Exception {
        RecordClient recordClient = new RecordClient();
        AuthenticityClient authenticityClient = new AuthenticityClient();
        KeyClient keyClient = new KeyClient();

        LocalKey localKey = keyClient.newLocalKey(KeyType.EcP256k);

        Record signedRecord = recordClient
                .fromString("Hello world")
                .withSigner(new EcdsaSigner(new SignerArgs(localKey, "some name")))
                .build();

        System.out.println("Record was signed successfully");

        List<Signature> signatures = authenticityClient.getSignatures(signedRecord);

        System.out.println("Record signed by: " + authenticityClient.getSignatureCommonName(signatures.get(0)));
    }
}

'
php='
<?php

require "./vendor/autoload.php";

use Bloock\Bloock;
use Bloock\Client\AuthenticityClient;
use Bloock\Client\KeyClient;
use Bloock\Client\RecordClient;
use Bloock\Entity\Authenticity\EcdsaSigner;
use Bloock\Entity\Authenticity\SignerArgs;
use Bloock\Entity\Key\KeyType;

Bloock::$apiKey = getenv("API_KEY");

$keyClient = new KeyClient();
$authenticityClient = new AuthenticityClient();
$recordClient = new RecordClient();

$keys = $keyClient->newLocalKey(KeyType::EcP256k);

$signedRecord = $recordClient->fromString("Hello world")
    ->withSigner(new EcdsaSigner(new SignerArgs($keys, "some name")))
    ->build();

print "Record was signed successfully\n";

$signatures = $authenticityClient->getSignatures($signedRecord);

$name = $authenticityClient->getSignatureCommonName($signatures[0]);
print "Record signed by: $name\n";
'
go='
import (
	"fmt"
	"log"

	"github.com/bloock/bloock-sdk-go/v2/client"
	"github.com/bloock/bloock-sdk-go/v2/client/entity"
)

func main() {
	recordClient := client.NewRecordClient()
	authenticityClient := client.NewAuthenticityClient()
	keyClient := client.NewKeyClient()

	key, err := keyClient.NewLocalKey(key.EcP256k)
	if err != nil {
		log.Fatalln(err)
	}

	name := "a name"
	signedRecord, err := recordClient.FromString("Hello world").
		WithSigner(entity.NewEcdsaSigner(entity.SignerArgs{
			LocalKey: &key,
			CommonName: &name,
		})).
		Build()
	if err != nil {
		log.Fatalln(err)
	}

	fmt.Println("Record was signed successfully")

	signatures, err := authenticityClient.GetSignatures(signedRecord)
	if err != nil {
		log.Fatalln(err)
	}

	signer, err := authenticityClient.GetSignatureCommonName(signatures[0])
	fmt.Println("Record signed by:", signer)
}
'
 />



